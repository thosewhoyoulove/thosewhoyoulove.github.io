# Node.js 的事件循环

Node.js 的事件循环（Event Loop）是其处理异步操作和非阻塞 I/O 的核心机制。由于 Node.js 采用单线程模型，所有的操作（尤其是 I/O 密集型操作）都依赖事件循环来调度执行，以保证高效的并发处理。下面详细介绍事件循环的工作原理。

## 事件循环的工作原理

Node.js 中的事件循环是基于单线程的，它允许在同一时间内处理多个 I/O 操作，而不需要多个线程。事件循环的运行是循环进行的，它会依次检查任务队列（如 I/O 操作、定时器等）并逐一执行。

事件循环分为几个不同的阶段，每个阶段会处理特定类型的任务。每个阶段都会有一个任务队列，事件循环依次从队列中取出任务执行。执行完一个阶段的所有任务后，事件循环会进入下一个阶段。

## 事件循环的各个阶段

事件循环的主要阶段如下：

- Timers（定时器阶段）

  - 在这个阶段，事件循环会执行所有已经过期的 setTimeout 和 setInterval 的回调函数。定时器会在设定的时间到达后执行，但会根据定时器的精度稍微有所延迟。
- I/O Callbacks（I/O 回调阶段）

  - 在这个阶段，事件循环会执行那些系统操作的回调，比如网络请求的回调函数、文件 I/O 的回调等。此时只有那些非阻塞操作（即不需要立即执行的 I/O）才会被执行。
- Idle, Prepare（空闲阶段）

  - 这个阶段是由 Node.js 内部使用的，用于执行一些内部操作。一般来说，用户代码不会直接与此阶段交互。
- Poll（轮询阶段）

  - 在这个阶段，事件循环会查看是否有新的 I/O 事件发生，如果有，则会执行相应的回调。如果没有新的 I/O 事件，事件循环会检查是否有定时器已经过期，并进入下一个阶段。

  - 如果轮询队列中有回调，事件循环会立即执行它们。如果轮询队列为空，事件循环会在此阶段等待新的事件到来。
- Check（检查阶段）

  - 这个阶段会执行通过 setImmediate() 提交的回调。setImmediate() 方法用于安排一个回调函数在当前事件循环的 "check" 阶段执行，而不会等待 I/O 操作完成。
- Close Callbacks（关闭回调阶段）

  - 这是事件循环的最后一个阶段。在此阶段，执行一些清理任务，比如关闭文件描述符、清理资源等。

## 事件循环的执行顺序

事件循环的顺序大致如下所示：

- 执行定时器回调（Timers 阶段）。
- 执行 I/O 回调（I/O Callbacks 阶段），例如网络请求和文件操作。
- 执行空闲阶段操作（Idle, Prepare 阶段）。
- 执行轮询回调（Poll 阶段），轮询是否有新的 I/O 操作需要处理。如果轮询队列为空，则进入下一个阶段。
- 执行 setImmediate() 的回调（Check 阶段）。
- 执行关闭回调（Close Callbacks 阶段）。

## 事件循环的调度流程

下面是一个简单的事件循环调度流程，来帮助理解它是如何工作的：

- Node.js 启动

  - Node.js 会启动并执行 JavaScript 文件中的代码。JavaScript 代码执行到 setTimeout()、setImmediate()、fs.readFile() 等异步操作时，Node.js 会将这些操作挂起并将相应的回调函数放入任务队列中。
- 任务执行

  - Node.js 会进入事件循环，逐一执行各个阶段的任务。在每个阶段，事件循环会检查是否有需要执行的回调，如果有就执行回调。
- 执行完成后，继续等待
 当事件循环完成所有的任务，且没有新的 I/O 操作或定时器待执行时，Node.js 会结束事件循环，进程将终止。
举个例子
假设我们有如下代码：

```javascript

console.log('start');

setTimeout(() => {
  console.log('timeout');
}, 0);

setImmediate(() => {
  console.log('immediate');
});

console.log('end');
```

输出顺序会是：

```bash
start
end
immediate
timeout
```

为什么会这样？

- 代码从上到下执行时，首先输出 'start' 和 'end'，因为它们是同步的。
- setTimeout 和 setImmediate 都是异步操作，但它们会被放入不同的队列：
  - setTimeout 在定时器阶段被处理，虽然设置为 0 毫秒，但它依然需要等到当前事件循环的阶段结束才能执行。
  - setImmediate 则会在 "check" 阶段执行，所以会比 setTimeout 的回调先执行。

setTimeout 和 setImmediate 的区别

- setTimeout() 是基于定时器的，它会在指定的时间间隔后执行回调，但这个回调会在定时器阶段被执行，不管有没有其他的 I/O 操作。

- setImmediate() 会在当前事件循环的 check 阶段执行，不管当前是否有待执行的定时器或 I/O 回调。

## 异常处理与事件循环

Node.js 中的错误通常通过回调函数来处理，但事件循环本身也可以处理未捕获的异常。常见的错误处理方法包括：

- try-catch：同步代码中的错误处理。
- process.on('uncaughtException')：监听未捕获的异常。
- process.on('unhandledRejection')：监听 Promise 未处理的拒绝。

## 总结

Node.js 的事件循环机制非常高效，因为它利用了 非阻塞 I/O 和 异步回调 来处理大量并发操作，而不需要像传统的多线程模型那样创建和管理多个线程。理解事件循环对编写高效的 Node.js 程序非常重要。
