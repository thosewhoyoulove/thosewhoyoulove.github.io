# Vue2 和 Vue3 的区别

## 1. 响应式原理

### Vue 2 的响应式原理(基于 Object.defineProperty )

核心原理：
Vue2 的响应式是通过 object.defineProperty()实现的，它只能劫持对象的已有属性，无法检测新加属性或数组的索引变动。

实现流程简述:

#### 1.初始化数据时，Vue 会遍历 data 中的每个属性，对其使用 object.defineProperty 设置 getter 和setter

#### 2.getter 作用

在模板中访问数据时触发，用于收集依赖(即把“谁在用这个数据"记录下来，比如 Watcher)。

#### 3. setter 作用

在修改数据时触发，用于通知依赖(更新视图等)。

#### 不足

- 新增/删除属性无法被监听(需要用 vue.set/vue.delete)
- 数组变动(比如通过 splice )需要特殊处理，Vue 重写了一些数组方法(比如 push，pop，splice等)来触发更新。

### Vue 3 的响应式原理(基于 Proxy)

核心原理：
Vue3 使用 Proxy 来实现响应式系统，可以直接代理整个对象，并且支持动态属性的添加和删除。

实现流程简述:

#### 1.使用 Proxy 包装整个对象，通过拦截器 get，set，deleteProperty 等来实现响应式

#### 2.get 中进行依赖收集(用 effect 注册依赖)

#### 3.set 中触发依赖更新

#### 4.所有依赖的追踪和触发通过一个核心模块: @vue/reactivity 来处理

#### 特点与优势

- 可以监听对象的新增/删除属性，
- 可以监听数组的索引和长度变化。
- 不再需要像 vue.set()这种 hack 方法,
- 性能更好，内存占用更低，结构更清晰。

## 2.diff算法

### QVue 2 的 Diff 算法(基于双端对比 + key 优化)

核心特点:

#### 1.采用双端比较算法(head-to-head和tail-to-tail)

同时从新旧节点的头部和尾部进行比较，遇到相同的就复用，不同的就移动或创建。

#### 2.基于 key 的优化重用

·若节点存在 key ，可以提高 diff 精度，准确判断节点是否复用。

#### 3.主要对比的是兄弟节点级别

Vue 2 不进行跨层级比较，仅对比同一父节点下的子节点，

### Vue 3 的 Diff 算法(基于双端 + 最长递增子序列 LIS)

Vue 3 的 diff 算法在 Vue2 的基础上进一步优化了移动操作的性能，主要体现在:

#### 1.新特性:最长递增子序列(LIS)

在 Vue 3 中，为了减少 DOM 移动操作，它会在有 key 的 diff 中找出最长递增子序列，表示”这些节点位置不变，其它才需要移动”。

#### 2.Diff 优化点

- 静态提升:
  Vue 3 会把静态不变的部分抽离，只染一次(性能极好)
- PatchFlag 标记差异:
  编译阶段会在 VNode 上打标记，告诉 runtime 哪部分需要精确 diff，避免不必要比较。
- 使用最长递增子序列优化移动次数:
  只移动必要的元素，提升性能。
